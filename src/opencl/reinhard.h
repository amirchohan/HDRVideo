const char *reinhard_kernel =
"\n"
"float3 RGBtoXYZ(float3 rgb);\n"
"\n"
"kernel void computeLogAvgLum( __global read_only float* image, __global float* logAvgLum, __global float* Ywhite) {\n"
"	//this kernel computes logAvgLum and Ywhite by performing reduction\n"
"	//the results are stored in an array of size num_work_groups\n"
"\n"
"	int gid = get_global_id(0);	//id in the entire global memory\n"
"\n"
"	float lum;\n"
"	float Ywhite_acc = 0.f;		//maximum luminance in the image\n"
"	float logAvgLum_acc = 0.f;\n"
"	while (gid < image_size) {\n"
"		lum = image[gid*4 + 0]*0.2126 + image[gid*4 + 1]*0.7152 + image[gid*4 + 2]*0.0722;\n"
"\n"
"		Ywhite_acc = (lum > Ywhite_acc) ? lum : Ywhite_acc;\n"
"		logAvgLum_acc += log(lum + 0.000001);\n"
"\n"
"		gid += get_global_size(0);\n"
"	}\n"
"\n"
"	__local float Ywhite_loc[32];\n"
"	__local float logAvgLum_loc[32];\n"
"\n"
"	int lid = get_local_id(0);	//id within the work group\n"
"	Ywhite_loc[lid] = Ywhite_acc;\n"
"	logAvgLum_loc[lid] = logAvgLum_acc;\n"
"\n"
"	// Perform parallel reduction\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	for(int offset = get_local_size(0)/2; offset > 0; offset = offset/2) {\n"
"		if (lid < offset) {\n"
"			Ywhite_loc[lid] = (Ywhite_loc[lid+offset] > Ywhite_loc[lid]) ? Ywhite_loc[lid+offset] : Ywhite_loc[lid];\n"
"			logAvgLum_loc[lid] += logAvgLum_loc[lid + offset];\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"	}\n"
"\n"
"	if (lid == 0) {\n"
"		Ywhite[get_group_id(0)] = Ywhite_loc[0];\n"
"		logAvgLum[get_group_id(0)] = logAvgLum_loc[0];\n"
"	}\n"
"\n"
"}\n"
"\n"
"kernel void global_TMO( __global float* input, __global float* output, __global float* logAvgLum_acc, __global float* Ywhite_acc) {\n"
"	float key = 1.0f;\n"
"	float sat = 1.5f;\n"
"\n"
"	float logAvgLum = logAvgLum_acc[0]+logAvgLum_acc[1]+logAvgLum_acc[2]+logAvgLum_acc[3]+logAvgLum_acc[4]+logAvgLum_acc[5];\n"
"	logAvgLum = exp(logAvgLum/image_size);\n"
"\n"
"	float Ywhite = 0.0f;\n"
"	for (int i=0; i<6; i++) {\n"
"		if (Ywhite < Ywhite_acc[i]) Ywhite = Ywhite_acc[i];\n"
"	}\n"
"\n"
"	const int gid = get_global_id(0);\n"
"	if (gid < image_size) {\n"
"		float3 rgb, xyz;\n"
"		rgb.x = input[gid*4 + 0];\n"
"		rgb.y = input[gid*4 + 1];\n"
"		rgb.z = input[gid*4 + 2];\n"
"\n"
"		xyz = RGBtoXYZ(rgb);\n"
"\n"
"		float Y\t= (key/logAvgLum) * xyz.y;\n"
"		float Yd = (Y * (1.0 + Y/(Ywhite * Ywhite)) )/(1.0 + Y);\n"
"\n"
"		output[gid*4 + 0] = clamp(pow(rgb.x/xyz.y, sat) * Yd, 0.f, 1.f);\n"
"		output[gid*4 + 1] = clamp(pow(rgb.y/xyz.y, sat) * Yd, 0.f, 1.f);\n"
"		output[gid*4 + 2] = clamp(pow(rgb.z/xyz.y, sat) * Yd, 0.f, 1.f);\n"
"		output[gid*4 + 3] = 0.f;\n"
"	}\n"
"}\n"
"\n"
"float3 RGBtoXYZ(float3 rgb) {\n"
"	float3 xyz;\n"
"	xyz.x = rgb.x*0.4124 + rgb.y*0.3576 + rgb.z*0.1805;\n"
"	xyz.y = rgb.x*0.2126 + rgb.y*0.7152 + rgb.z*0.0722;\n"
"	xyz.z = rgb.x*0.0193 + rgb.y*0.1192 + rgb.z*0.9505;\n"
"	return xyz;\n"
"}\n";
