const char *histEq_kernel =
"\n"
"\n"
"float3 RGBtoHSV(float3 rgb);\n"
"float3 HSVtoRGB(float3 hsv);\n"
"\n"
"//computes the histogram for brightness\n"
"kernel void partial_hist(__global float* image, __global uint* partial_histogram) {\n"
"	const int global_size = get_global_size(0);\n"
"	const int group_size = get_local_size(0);\n"
"	const int group_id = get_group_id(0);\n"
"	const int lid = get_local_id(0);\n"
"\n"
"	__local uint l_hist[HIST_SIZE];\n"
"	for (int i = lid; i < HIST_SIZE; i+=group_size) {\n"
"		l_hist[i] = 0;\n"
"	}\n"
"\n"
"	int brightness;\n"
"	for (int i = get_global_id(0); i < image_size; i += global_size) {\n"
"		brightness = max(max(image[i*NUM_CHANNELS + 0], image[i*NUM_CHANNELS + 1]), image[i*NUM_CHANNELS + 2])*(HIST_SIZE-1);\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"		atomic_inc(&l_hist[brightness]);\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	for (int i = lid; i < HIST_SIZE; i+=group_size) {\n"
"		partial_histogram[i + group_id * HIST_SIZE] = l_hist[i];\n"
"	}\n"
"}\n"
"\n"
"kernel void merge_hist(__global uint* partial_histogram, __global uint* histogram, __local uint* l_Data, const int num_hists) {\n"
"\n"
"	const int group_size = get_local_size(0);\n"
"	const int lid = get_local_id(0);\n"
"	const int group_id = get_group_id(0);\n"
"\n"
"	uint sum = 0;\n"
"	for(uint i = lid; i < num_hists; i += group_size)\n"
"		sum += partial_histogram[group_id + i * HIST_SIZE];\n"
"\n"
"	l_Data[lid] = sum;\n"
"	for(uint stride = group_size/2; stride > 0; stride >>= 1){\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"		if(lid < stride) l_Data[lid] += l_Data[lid + stride];\n"
"	}\n"
"\n"
"	if(lid == 0) histogram[group_id] = l_Data[0];\n"
"}\n"
"\n"
"//TODO: even though this takes barely anytime at all, could look into parrallel scan in future\n"
"//computes the cdf of the brightness histogram\n"
"kernel void hist_cdf( __global uint* hist) {\n"
"	const int gid = get_global_id(0);\n"
"	const int global_size = get_global_size(0);\n"
"\n"
"	if (gid==0)\n"
"		for (int i=1; i<global_size; i++) {\n"
"			hist[i] += hist[i-1];\n"
"		}\n"
"}\n"
"\n"
"//kernel to perform histogram equalisation using the modified brightness cdf\n"
"kernel void histogram_equalisation( __global float* image, __global uint* brightness_cdf) {\n"
"	for (int i= get_global_id(0); i < image_size; i+=get_global_size(0)) {\n"
"		float3 rgb = (float3) (image[i*NUM_CHANNELS + 0], image[i*NUM_CHANNELS + 1], image[i*NUM_CHANNELS + 2]);\n"
"		float3 hsv = RGBtoHSV(rgb);		//Convert to HSV to get Hue and Saturation\n"
"\n"
"		hsv.z = ((HIST_SIZE-1)*(brightness_cdf[(int)hsv.z] - brightness_cdf[0]))\n"
"					/(image_size - brightness_cdf[0]);\n"
"\n"
"		rgb = HSVtoRGB(hsv);	//Convert back to RGB with the modified brightness for V\n"
"		image[i*NUM_CHANNELS + 0] = rgb.x;\n"
"		image[i*NUM_CHANNELS + 1] = rgb.y;\n"
"		image[i*NUM_CHANNELS + 2] = rgb.z;\n"
"	}\n"
"}\n"
"\n"
"float3 RGBtoHSV(float3 rgb) {\n"
"	float r = rgb.x*(HIST_SIZE-1);\n"
"	float g = rgb.y*(HIST_SIZE-1);\n"
"	float b = rgb.z*(HIST_SIZE-1);\n"
"	float rgb_min, rgb_max, delta;\n"
"	rgb_min = min(min(r, g), b);\n"
"	rgb_max = clamp(max(max(r, g), b), 0.f, HIST_SIZE*1.f-1);\n"
"\n"
"	float3 hsv;\n"
"\n"
"	hsv.z = rgb_max;	//Brightness\n"
"	delta = rgb_max - rgb_min;\n"
"	if(rgb_max != 0) hsv.y = delta/rgb_max;//Saturation\n"
"	else {	// r = g = b = 0	//Saturation = 0, Value is undefined\n"
"		hsv.y = 0;\n"
"		hsv.x = -1;\n"
"		return hsv;\n"
"	}\n"
"\n"
"	//Hue\n"
"	if(r == rgb_max) 		hsv.x = (g-b)/delta;\n"
"	else if(g == rgb_max) 	hsv.x = (b-r)/delta + 2;\n"
"	else 			 		hsv.x = (r-g)/delta + 4;\n"
"	hsv.x *= 60;				\n"
"	if( hsv.x < 0 ) hsv.x += 360;\n"
"\n"
"	return hsv;\n"
"}\n"
"\n"
"float3 HSVtoRGB(float3 hsv) {\n"
"	int i;\n"
"	float h = hsv.x;\n"
"	float s = hsv.y;\n"
"	float v = hsv.z;\n"
"	float f, p, q, t;\n"
"	float3 rgb;\n"
"	if( s == 0 ) { // achromatic (grey)\n"
"		rgb.x = rgb.y = rgb.z = v/(HIST_SIZE-1);\n"
"		return rgb;\n"
"	}\n"
"	h /= 60;			// sector 0 to 5\n"
"	i = floor( h );\n"
"	f = h - i;			// factorial part of h\n"
"	p = v * ( 1 - s );\n"
"	q = v * ( 1 - s * f );\n"
"	t = v * ( 1 - s * ( 1 - f ) );\n"
"	switch( i ) {\n"
"		case 0:\n"
"			rgb.x = v;\n"
"			rgb.y = t;\n"
"			rgb.z = p;\n"
"			break;\n"
"		case 1:\n"
"			rgb.x = q;\n"
"			rgb.y = v;\n"
"			rgb.z = p;\n"
"			break;\n"
"		case 2:\n"
"			rgb.x = p;\n"
"			rgb.y = v;\n"
"			rgb.z = t;\n"
"			break;\n"
"		case 3:\n"
"			rgb.x = p;\n"
"			rgb.y = q;\n"
"			rgb.z = v;\n"
"			break;\n"
"		case 4:\n"
"			rgb.x = t;\n"
"			rgb.y = p;\n"
"			rgb.z = v;\n"
"			break;\n"
"		default:		// case 5:\n"
"			rgb.x = v;\n"
"			rgb.y = p;\n"
"			rgb.z = q;\n"
"			break;\n"
"	}\n"
"	rgb.x = rgb.x/(HIST_SIZE-1);\n"
"	rgb.y = rgb.y/(HIST_SIZE-1);\n"
"	rgb.z = rgb.z/(HIST_SIZE-1);\n"
"	return rgb;\n"
"}\n";
