const char *histEq_kernel =
"\n"
"float3 RGBtoHSV(float r, float g, float b);\n"
"uchar3 HSVtoRGB(float h, float s, float v);\n"
"\n"
"//computes the histogram for brightness\n"
"kernel void brightness_partial_hist( __global unsigned char* image,\n"
"							__global unsigned int* partial_histogram,\n"
"							__global unsigned int* brightness_hist) {\n"
"\n"
"	const int gid = get_global_id(0);\n"
"\n"
"	if (gid < image_size) {\n"
"		const int b = max(max(image[gid*3 + 0], image[gid*3 + 1]), image[gid*3 + 2]);\n"
"		const int tid = get_local_id(0);\n"
"		local uint local_hist[256];\n"
"\n"
"		if(tid < 256) local_hist[tid] = 0;	//this will only work if local size >= 256\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"		atomic_inc(&local_hist[b]);\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);	//this will only work if local size >= 256\n"
"		if (tid < 256) {\n"
"			partial_histogram[256*get_group_id(0) + tid] = local_hist[tid];\n"
"			brightness_hist[tid] = 0;\n"
"		}\n"
"	}\n"
"	return;\n"
"}\n"
"\n"
"kernel void brightness_hist(__global unsigned int* partial_histogram,\n"
"							__global unsigned int* brightness_hist) {\n"
"	const int gid = get_global_id(0);\n"
"	unsigned int sum = partial_histogram[256 + gid];\n"
"\n"
"	//num_workgroups is the number of workgroups in the previous kernel\n"
"	for (int i = 1; i < num_workgroups; i++) {\n"
"		sum += partial_histogram[256*i + gid];\n"
"	}\n"
"	brightness_hist[gid] = sum;\n"
"}\n"
"\n"
"//computes the cdf of the brightness histogram\n"
"kernel void hist_cdf( __global unsigned int* hist) {\n"
"	const int gid = get_global_id(0);\n"
"	const int global_size = get_global_size(0);\n"
"\n"
"	if (gid==0)\n"
"		for (int i=1; i<global_size; i++) {\n"
"			hist[i] += hist[i-1];\n"
"		}\n"
"	return;\n"
"}\n"
"\n"
"//kernel to modify the brightness in the original image\n"
"kernel void modify_brightness( __global unsigned char* image,\n"
"							__global unsigned int* brightness_cdf) {\n"
"	const int i = get_global_id(0);\n"
"\n"
"	if (i < image_size) {\n"
"		float r = image[i*3 + 0];	//Red\n"
"		float g = image[i*3 + 1];	//Green\n"
"		float b = image[i*3 + 2];	//Blue\n"
"		float3 hsv = RGBtoHSV(r, g, b);		//Convert to HSV to get Hue and Saturation\n"
"\n"
"		hsv.z = (255*(brightness_cdf[(int)hsv.z] - brightness_cdf[0]))\n"
"					/(image_size - brightness_cdf[0]);\n"
"\n"
"		uchar3 rgb = HSVtoRGB(hsv.x, hsv.y, hsv.z);	//Convert back to RGB with the modified brightness for V\n"
"		image[i*3 + 0] = rgb.x;\n"
"		image[i*3 + 1] = rgb.y;\n"
"		image[i*3 + 2] = rgb.z;	\n"
"	}\n"
"	return;\n"
"}\n"
"\n"
"float3 RGBtoHSV(float r, float g, float b) {\n"
"	float rgb_min = min(min(r, g), b);\n"
"	float rgb_max = max(max(r, g), b);\n"
"\n"
"	float hue, sat, val;\n"
"\n"
"	//Value\n"
"	val = rgb_max;\n"
"\n"
"	//Saturation\n"
"	float delta = rgb_max - rgb_min;\n"
"	if(rgb_max != 0) sat = delta/rgb_max;\n"
"	else {	// r = g = b = 0	//Saturation = 0, Value is undefined\n"
"		return (float3) (-1, 0, 0);\n"
"	}\n"
"\n"
"	//Hue\n"
"	if(r == rgb_max) 		hue = (g-b)/delta;\n"
"	else if(g == rgb_max) 	hue = (b-r)/delta + 2;\n"
"	else 					hue = (r-g)/delta + 4;\n"
"	hue *= 60;				\n"
"	if(hue < 0) hue += 360;\n"
"\n"
"	return (float3) (hue, sat, val);\n"
"}\n"
"\n"
"uchar3 HSVtoRGB(float h, float s, float v) {\n"
"	uchar r, g, b;\n"
"	if( s == 0 ) { // achromatic (grey)\n"
"		return (uchar3) (v, v, v);\n"
"	}\n"
"	int i;\n"
"	float f, p, q, t;\n"
"	h /= 60;			// sector 0 to 5\n"
"	i = floor( h );\n"
"	f = h - i;			// factorial part of h\n"
"	p = v * ( 1 - s );\n"
"	q = v * ( 1 - s * f );\n"
"	t = v * ( 1 - s * ( 1 - f ) );\n"
"	switch( i ) {\n"
"		case 0:\n"
"			r = v;\n"
"			g = t;\n"
"			b = p;\n"
"			break;\n"
"		case 1:\n"
"			r = q;\n"
"			g = v;\n"
"			b = p;\n"
"			break;\n"
"		case 2:\n"
"			r = p;\n"
"			g = v;\n"
"			b = t;\n"
"			break;\n"
"		case 3:\n"
"			r = p;\n"
"			g = q;\n"
"			b = v;\n"
"			break;\n"
"		case 4:\n"
"			r = t;\n"
"			g = p;\n"
"			b = v;\n"
"			break;\n"
"		default:		// case 5:\n"
"			r = v;\n"
"			g = p;\n"
"			b = q;\n"
"			break;\n"
"	}\n"
"	return (uchar3) (r, g, b);\n"
"}\n";
